
#include "gmakegen.h"

#include "../model/gscope.h"
#include "futil/util/txtemit.h"
#include "futil/util/filelist.h"
#include "../util/genfile.h"

inline std::string objectName(const std::string& f) {
	std::string o(f);
	std::string::size_type pos = o.rfind(".");
	if (pos == o.npos) return "";
	if (pos >= o.size()) return "";
	if ('c' != o[++pos]) return "";
	o.erase(pos);
	o.append("o");
	return o;
}

#include "../util/cookpath.h"
#include "../util/fileext.h"

static inline void cookPath(std::string& path, const std::string& root) {
	cookPath_(path, root);
//	replaceAll(path, '/', '\\');
}

inline std::string parentDir(const std::string& path) {
	std::string p(path);
	std::string::size_type pos = p.rfind("/");
	if (pos == p.npos) return "";
	p.erase(pos);
	return p;
}

static inline std::vector<std::string> buildSelectors(const std::string& configuration, const std::string& platform) {
	std::vector<std::string> selectors = { "gcc", "linux" };
	selectors.push_back(configuration);
	selectors.push_back(platform);
	return selectors;
}

static inline std::string targetDir(jinn::model::Project* p, jinn::model::Solution* s, const std::vector<std::string>& selectors, const std::string& root) {
	std::string tmp = p->findConfigVal(*s, "targetdir", selectors);
	if (tmp.empty()) tmp = "bin";
//	if ('/' != *tmp.rbegin()) tmp += '/';
	cookPath(tmp, root);
	return tmp;
}

static inline std::string targetFile(jinn::model::Project* p, jinn::model::Solution* s, const std::vector<std::string>& selectors) {
	std::string targetName = p->findConfigVal(*s, "targetname", selectors);
	if (targetName.empty()) targetName = p->key;

	std::string kind = p->findConfigVal(*s, "kind", selectors); 
	std::string tmp;
	if (kind == "StaticLib") {
		tmp += "lib" + targetName + ".a";
	} else {
		tmp += p->key;
	}

	return tmp;
}

inline std::string pcollapse(const std::vector<std::string>& vals, const char* delim) {
	std::string result;
	for (auto& val : vals) {
		result += delim;
		result += val;
	}
	return result;
}

inline bool jinn::generator::GMakeGenerator::generateProject(jinn::model::Project* p, jinn::model::Solution* s, futil::util::FileList& filelist) {
	std::vector<std::string>& files = filelist.files;
	jinn::util::GeneratedFile proj(testMode); 
	proj.init(*p);
	if (!proj.open("Makefile", "")) return false;
	futil::util::TextEmitter e(proj.out, '\t', 1);
	std::string tmp;
	std::string root = proj.location + "/";

	std::vector<std::string> platforms = s->findVals("platforms");
	std::vector<std::string> configurations = s->findVals("configurations");
	std::vector<jinn::model::Project> refs = s->findProjectReferences(p);

	e.emit("# GNU Make project makefile generated by jinn");
	e.emit("ifndef config");
	e.emit("  config=release-static64");
	e.emit("endif");
	e.emit("");
	e.emit("ifndef verbose");
	e.emit("  SILENT = @");
	e.emit("endif");
	e.emit("");
	e.emit("SHELLTYPE := msdos");
	e.emit("ifeq (,$(ComSpec)$(COMSPEC))");
	e.emit("  SHELLTYPE := posix");
	e.emit("endif");
	e.emit("ifeq (/bin,$(findstring /bin,$(SHELL)))");
	e.emit("  SHELLTYPE := posix");
	e.emit("endif");
	e.emit("ifeq (/bin,$(findstring /bin,$(MAKESHELL)))");
	e.emit("  SHELLTYPE := posix");
	e.emit("endif");
	e.emit("");
	e.emit("ifeq (posix,$(SHELLTYPE))");
	e.emit("  MKDIR = $(SILENT) mkdir -p \"$(1)\"");
	e.emit("  COPY  = $(SILENT) cp -fR \"$(1)\" \"$(2)\"");
	e.emit("  RM    = $(SILENT) rm -f \"$(1)\"");
	e.emit("else");
	e.emit("  MKDIR = $(SILENT) mkdir \"$(subst /,\\\\,$(1))\" 2> nul || exit 0");
	e.emit("  COPY  = $(SILENT) copy /Y \"$(subst /,\\\\,$(1))\" \"$(subst /,\\\\,$(2))\"");
	e.emit("  RM    = $(SILENT) del /F \"$(subst /,\\\\,$(1))\" 2> nul || exit 0");
	e.emit("endif");
	e.emit("");
	e.emit("CC  = gcc");
	e.emit("CXX = g++");
	e.emit("AR  = ar");
	e.emit("");
	e.emit("ifndef RESCOMP");
	e.emit("  ifdef WINDRES");
	e.emit("    RESCOMP = $(WINDRES)");
	e.emit("  else");
	e.emit("    RESCOMP = windres");
	e.emit("  endif");
	e.emit("endif");
	e.emit("");
	e.emit("MAKEFILE = Makefile");
	e.emit("");
	std::string kind;  // Needed by make rule for $(TARGET), which is global!  It should be config/platform specific...
	for(auto& conf : configurations) {
		for (auto& plat : platforms) {
			std::vector<std::string> selectors = buildSelectors(conf, plat);

			e.emit("ifeq ($(config),release-static64)");
			e.emit("  OBJDIR              = .objs/x64");

			tmp = targetDir(p, s, selectors, root);
			tmp.insert(0, "  TARGETDIR           = " );
			e.emit(tmp.c_str());

			kind = p->findConfigVal(*s, "kind", selectors);   // for global

			tmp = targetFile(p, s, selectors);
			tmp.insert(0, "  TARGET              = $(TARGETDIR)/");
			e.emit(tmp.c_str());

			tmp = "  DEFINES            +=";
			auto defs = p->findAllConfigVals(*s, "defines", selectors ).vals;
			for (auto def : defs) {
				tmp.append(" -D"); tmp.append(def);
			}
			e.emit(tmp.c_str());

			std::string bopts, bopts_cpp;
			bopts += " -g -O2 -m64";  // FIXME
			if (p->findAllFlags(*s, "AllWarnings", selectors))
				bopts += " -Wall";
			if (p->findAllFlags(*s, "FatalWarnings", selectors))
				bopts += " -Werror";
			auto buildopts = p->findAllConfigVals(*s, "buildoptions", selectors ).vals;
			for (auto buildopt : buildopts) {
				bopts.append(" "); bopts.append(buildopt);
			}
			buildopts = p->findAllConfigVals(*s, "buildoptions_cpp", selectors ).vals;
			for (auto buildopt : buildopts) {
				bopts_cpp.append(" "); bopts_cpp.append(buildopt);
			}

			auto incs = p->findConfigVals(*s, "includedirs", selectors ).vals;
			if (!incs.empty()) {
				tmp = "  INCLUDES           +=";
				for (auto inc : incs) {
					cookPath(inc, root);
					tmp += " -I\"";
					tmp += inc;
					tmp += "\"";
				}
				e.emit(tmp.c_str());
			}

			e.emit("  ALL_CPPFLAGS       += $(CPPFLAGS) -MMD -MP -MP $(DEFINES) $(INCLUDES)");
			e.emit(("  ALL_ASMFLAGS       += $(ASMFLAGS) $(CFLAGS) $(ALL_CPPFLAGS) $(ARCH)" + bopts).c_str());
			e.emit(("  ALL_CFLAGS         += $(CFLAGS) $(ALL_CPPFLAGS) $(ARCH)" + bopts).c_str());
			e.emit(("  ALL_CXXFLAGS       += $(CXXFLAGS) $(CFLAGS) $(ALL_CPPFLAGS) $(ARCH)" + bopts + bopts_cpp).c_str());
			e.emit(("  ALL_OBJCFLAGS      += $(CFLAGS) $(ALL_CPPFLAGS) $(ARCH)" + bopts).c_str());
			e.emit(("  ALL_OBJCPPFLAGS    += $(CXXFLAGS) $(CFLAGS) $(ALL_CPPFLAGS) $(ARCH)" + bopts).c_str());
			e.emit("  ALL_RESFLAGS       += $(RESFLAGS) $(DEFINES) $(INCLUDES)");

			std::vector<std::string> libDirs;
			auto ldirs = p->findConfigVals(*s, "libdirs", selectors).vals;
			for (auto ldir : ldirs) {
				cookPath(ldir, root);
				libDirs.push_back(ldir);
			}
			
			std::string deps = "  LDDEPS             +=";
			libDirs.push_back("");
			for (auto ref : refs) {
				std::string refDir = targetDir(&ref, s, selectors, root);
				deps += " " + refDir + "/" + targetFile(&ref, s, selectors);
				if (refDir != libDirs.back())
					libDirs.push_back(refDir);
			}

			tmp = "  ALL_LDFLAGS        += $(LDFLAGS)";
			for (auto libDir : libDirs) {
				if (libDir.empty()) continue;
				tmp += " -L"; tmp += libDir;
			}

			tmp += " -m64"; // FIXME
			auto linkopts = p->findConfigVals(*s, "linkoptions", selectors ).vals;
			for (auto linkopt : linkopts) {
				tmp.append(" "); tmp.append(linkopt);
			}
			e.emit(tmp.c_str());
			e.emit(deps.c_str());

			std::string libs = "  LIBS               += $(LDDEPS)";
			std::vector<std::string> links = p->findAllConfigVals(*s, "links", selectors ).vals;
			for (auto& ref : refs) 
				for(auto it = links.begin(); it != links.end(); it++) 
					if (ref.key == *it) { links.erase(it); break; }
			tmp = pcollapse(links, " -l");
			if (!tmp.empty()) 
				libs.append(tmp);
			e.emit(libs.c_str());

			e.emit("  EXTERNAL_LIBS      +=");
			if (kind == "StaticLib") 
				e.emit("  LINKCMD             = $(AR)  -rcs $(TARGET)");
			else 
				e.emit("  LINKCMD             = $(CXX) -o $(TARGET) $(OBJECTS) $(RESOURCES) $(ARCH) $(ALL_LDFLAGS) $(LIBS)");
			e.emit("  OBJECTS := \\");
			for (auto f : files) {
				auto o = objectName(f);
				if (o.empty()) continue;
				cookPath(o, root);
				tmp = "\t$(OBJDIR)/" + o + " \\";
				e.emit(tmp.c_str());
			}
			e.emit("");
			e.emit("  define PREBUILDCMDS");
			e.emit("  endef");
			e.emit("  define PRELINKCMDS");
			e.emit("  endef");
			e.emit("  define POSTBUILDCMDS");
			e.emit("  endef");
			e.emit("endif");

		}
	}

	std::vector<std::string> odirs; odirs.push_back(".");
	for (auto f : files) {
		auto o = objectName(f);
		if (o.empty()) continue;
		cookPath(o, root);
		std::string odir = parentDir(o);
		if ((odir != odirs.back()) && !odir.empty())
			odirs.push_back(odir);
	}

	e.emit("");
	e.emit("OBJDIRS := \\");
	e.emit("\t$(OBJDIR) \\");
	for (auto odir : odirs) {
		tmp = "\t$(OBJDIR)/" + odir + " \\";
		e.emit(tmp.c_str());
	}
	e.emit("");

	e.emit("RESOURCES := \\");
	e.emit("");
	e.emit(".PHONY: clean prebuild prelink");
	e.emit("");
	e.emit("all: $(OBJDIRS) $(TARGETDIR) prebuild prelink $(TARGET)");
	e.emit("\t@:");
	e.emit("");
	e.emit("$(TARGET): $(GCH) $(OBJECTS) $(LDDEPS) $(EXTERNAL_LIBS) $(RESOURCES) | $(TARGETDIR) $(OBJDIRS)");
	if (kind == "StaticLib") {
		tmp = "\t@echo Archiving " + p->key;
		e.emit(tmp.c_str());
		e.emit("ifeq (posix,$(SHELLTYPE))");
		e.emit("\t$(SILENT) rm -f  $(TARGET)");
		e.emit("else");
		e.emit("\t$(SILENT) if exist $(subst /,\\\\,$(TARGET)) del $(subst /,\\\\,$(TARGET))");
		e.emit("endif");
		e.emit("\t$(SILENT) $(LINKCMD) $(OBJECTS)");
	} else {
		tmp = "\t@echo Linking " + p->key;
		e.emit(tmp.c_str());
		e.emit("\t$(SILENT) $(LINKCMD)");
	}
	e.emit("\t$(POSTBUILDCMDS)");
	e.emit("");
	e.emit("$(TARGETDIR):");
	e.emit("\t@echo Creating $(TARGETDIR)");
	e.emit("\t-$(call MKDIR,$(TARGETDIR))");
	e.emit("");
	e.emit("$(OBJDIRS):");
	e.emit("\t@echo Creating $(@)");
	e.emit("\t-$(call MKDIR,$@)");
	e.emit("");
	e.emit("clean:");
	tmp = "\t@echo Cleaning " + p->key;
	e.emit(tmp.c_str());
	e.emit("ifeq (posix,$(SHELLTYPE))");
	e.emit("\t$(SILENT) rm -f  $(TARGET)");
	e.emit("\t$(SILENT) rm -rf $(OBJDIR)");
	e.emit("else");
	e.emit("\t$(SILENT) if exist $(subst /,\\\\,$(TARGET)) del $(subst /,\\\\,$(TARGET))");
	e.emit("\t$(SILENT) if exist $(subst /,\\\\,$(OBJDIR)) rmdir /s /q $(subst /,\\\\,$(OBJDIR))");
	e.emit("endif");
	e.emit("");
	e.emit("prebuild:");
	e.emit("\t$(PREBUILDCMDS)");
	e.emit("");
	e.emit("prelink:");
	e.emit("\t$(PRELINKCMDS)");
	e.emit("");
	e.emit("ifneq (,$(PCH))");
	e.emit("$(GCH): $(PCH) $(MAKEFILE) | $(OBJDIR)");
	e.emit("\t@echo $(notdir $<)");
	e.emit("\t$(SILENT) $(CXX) $(ALL_CXXFLAGS) -x c++-header $(DEFINES) $(INCLUDES) -o \"$@\" -c \"$<\"");
	e.emit("");
	e.emit("$(GCH_OBJC): $(PCH) $(MAKEFILE) | $(OBJDIR)");
	e.emit("\t@echo $(notdir $<)");
	e.emit("\t$(SILENT) $(CXX) $(ALL_OBJCPPFLAGS) -x objective-c++-header $(DEFINES) $(INCLUDES) -o \"$@\" -c \"$<\"");
	e.emit("endif");
	e.emit("");
	for (auto f : files) {
		auto o = objectName(f);
		if (o.empty()) continue;
		cookPath(o, root);
		std::string ff(f);
		cookPath(ff, root);
		tmp = "$(OBJDIR)/" + o + ": " + ff + " $(GCH) $(MAKEFILE)";
		e.emit(tmp.c_str());
		e.emit("\t@echo $(notdir $<)");
		if (".c" == fileExtension(f))
			e.emit("\t$(SILENT) $(CC) $(ALL_CFLAGS) $(FORCE_INCLUDE) -o \"$@\" -c \"$<\"");
		else
			e.emit("\t$(SILENT) $(CXX) $(ALL_CXXFLAGS) $(FORCE_INCLUDE) -o \"$@\" -c \"$<\"");
		e.emit("");
	}
	e.emit("-include $(OBJECTS:%.o=%.d)");
	e.emit("ifneq (,$(PCH))");
	e.emit("  -include $(OBJDIR)/$(notdir $(PCH)).d");
	e.emit("  -include $(OBJDIR)/$(notdir $(PCH))_objc.d");
	e.emit("endif");

	return true;
}

#include <algorithm>

#include "../util/filelist.h"

inline bool jinn::generator::GMakeGenerator::generate(jinn::model::Project* p, jinn::model::Solution* s) {
	futil::util::FileList filelist = buildFileList(p);
	std::sort(filelist.files.begin(), filelist.files.end());
	return generateProject(p,s,filelist);
}

inline bool jinn::generator::GMakeGenerator::generateProjects(jinn::model::Solution* s) {
	int succ = 0, fail = 0;
	for(auto& p : s->projects)  {
		if (generate(&p,s))
			succ++;
		else
			fail++;
	}
	std::cout << succ << " projects" << std::endl;
	if (fail)
		std::cerr << fail << " projects failed!" << std::endl;
	return fail == 0;
}

inline bool jinn::generator::GMakeGenerator::generate(jinn::model::Solution* s) {
	jinn::util::GeneratedFile sln(testMode); 
	sln.init(*s);
	if (!sln.open("Makefile", "")) return false;
	futil::util::TextEmitter e(sln.out, '\t', 1);
	e.emit("# GNU Make solution makefile generated by jinn");
	e.emit("# 'make help' for help");
	e.emit("");
	e.emit("ifndef config");
	e.emit("  config=release-static64");
	e.emit("endif");
	e.emit("export config");  // XXX
	e.emit("");
	std::string tmp("PROJECTS :=");
	for(auto& proj : s->projects) { tmp.push_back(' '); tmp.append(proj.key); }
	e.emit(tmp.c_str());
	e.emit("");
	e.emit(".PHONY: all clean help $(PROJECTS)");
	e.emit("");
	e.emit("all: $(PROJECTS)");
	for (auto& proj : s->projects) {
		e.emit("");
		tmp = proj.key + ":"; 
		std::vector<jinn::model::Project> refs = s->findProjectReferences(&proj);
		for (auto ref : refs)
			tmp += " " + ref.key;
		e.emit(tmp.c_str());
		tmp = "\t@echo \"==== Building " + proj.key + " ($(config)) ====\"";
		e.emit(tmp.c_str());
		tmp = "\t@${MAKE} --no-print-directory -C " + proj.key + " -f Makefile";
		e.emit(tmp.c_str());
	}
	e.emit("");
	e.emit("clean:");
	for (auto& proj : s->projects) {
		tmp = "\t@${MAKE} --no-print-directory -C " + proj.key + " -f Makefile clean";
		e.emit(tmp.c_str());
	}
	e.emit("");
	e.emit("help:");
	e.emit("\t@echo \"Usage: make [config=name] [target]\"");
	e.emit("\t@echo \"\"");
	e.emit("\t@echo \"CONFIGURATIONS:\"");
	e.emit("\t@echo \"   release-static64\"");
	e.emit("\t@echo \"\"");
	e.emit("\t@echo \"TARGETS:\"");
	e.emit("\t@echo \"   all (default)\"");
	e.emit("\t@echo \"   clean\"");
	for (auto& proj : s->projects) {
		tmp = "\t@echo \"   " + proj.key + "\"";
		e.emit(tmp.c_str());
	}
	e.emit("\t@echo \"\"");
//	e.emit("\t@echo \"\"");
	generateProjects(s);
	return true;
}

inline bool jinn::generator::GMakeGenerator::generateSolutions(jinn::model::GlobalScope* g) {
	int succ = 0, fail = 0;
	for(auto& s : g->solutions) 
		if (generate(&s))
			succ++;
		else
			fail++;
	std::cout << succ << " solutions" << std::endl;
	if (fail)
		std::cerr << fail << " solutions failed!" << std::endl;
	return fail == 0;
}

void jinn::generator::GMakeGenerator::generate(model::GlobalScope* g) {

	generateSolutions(g);

}


